"use strict";var e=require("readline"),o=require("path"),t=require("url");function r(e){var o=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(o,t,r.get?r:{enumerable:!0,get:function(){return e[t]}})}})),o.default=e,Object.freeze(o)}var n=r(e);const s=t.fileURLToPath("undefined"==typeof document?require("url").pathToFileURL(__filename).href:document.currentScript&&document.currentScript.src||new URL("index.min.cjs",document.baseURI).href);o.dirname(s);class c{tools=[];constructor(){}addTool(e){this.tools.push(e)}runTool(e){const o=this.tools.find((o=>o.name===e));if(!o)throw new Error(`Tool ${e} not found`);o.function()}}const u=new class{toolRunner=new c;constructor(){}addTool(e){this.toolRunner.addTool(e)}run(){if(process.argv.length<3)throw new Error("No tool name provided");const e=process.argv[2];this.toolRunner.runTool(e)}};const i=new class{constructor(){}async prompt(e){const o=await this.input(`[37;1m${e}: [0m`);return void 0!==o?o:Promise.reject("Answer could not be parsed to specified type")}async dichotomous(e){return await this.input(`[37;1m${e} (y/n): [0m`).then((e=>e.toLowerCase())),!1}async input(e){return new Promise((o=>{const t=n.createInterface({input:process.stdin,output:process.stdout});t.question(e,(e=>{t.close(),o(e)}))}))}out(e){console.log(e)}success(e){console.log("[32;1m%s[0m",e)}bold(e){console.log("[37;1m%s[0m",e)}warn(e){console.log("[33;1m%s[0m",e)}header(e){console.log("[34;1;4m%s[0m",e)}error(e){console.log("[31;1m%s[0m",e)}};u.addTool({name:"say-hello",description:"Says hello",function:()=>{i.out("Hello!")}}),u.run(),process.exit(0);
